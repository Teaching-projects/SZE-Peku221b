\documentclass[12ppt,a4paper,oneside]{report}

\usepackage{makrok}

\author{Szili Dániel, Schöffer Fruzsina, Tóth Sándor Balázs, Varga Máté\\\ \\Témavezető: Dr. Hegyháti Máté}
\title{Zebra típusú logikai rejtvények megoldása evolúciós algoritmussal}

\begin{document}

\maketitle

\tableofcontents

\chapter{Bevezetés} % unassigned
    \todo{Absztrakt bovebben, szoveges tartalomjegyzek}

\chapter{Zebra rejtvények} % Balázs
    \todo{Egy bevezeto mondat, + hogy melyik alfejezetben mi lesz}
    
    \section{Történet és szerkezet} % Balázs
        \todo{Miert zebra, mikbol all a rejtveny, Einstein peldajabol reszlet akar}

    \section{Megoldhatóság, egyértelműség} % Balázs
        \todo{Pici peldakon bemutatni, hogy ha rosszak a szabalyok, akkor lehet nincs megoldas, vagy ha keves a szabaly, akkor lehet tobb megoldas is van. Egy nagyon apro (3 szek, 2 tulajdonsag mondjuk) pelda kitalalasa es megoldasa par lepesben. }

    \section{Megoldó módszerek} % Balázs
        \todo{Irodalomban talalhato modszerek, 2 mondat roluk, hivatkozasok}

\chapter{Evolúciós algoritmusok} % Balázs
    \todo{Tortenetuk, hivatkozasok}
    \todo{Altalanos felepitesuk}
    \todo{Akar par szo arrol, mi mindenre alkalmaztak oket, hivatkozasok}

\chapter{Evolúciós algoritmus Zebra rejtvények megfejtésére} % unassigned
    \todo{Par mondat az alapveto elgondolasrol, hogy melyik fejezetben mirol lesz szo}

    \section{Kódszerkezet} % Dani
			{A kód alapvetően 2 logikai egységre szedhető szét. Van egy egységes, genetikus kód rész és egy az adott feladatra vonatkozó specifikációkat tartalmazó rész. Ez a genetikus algoritmusban három különböző részre jól elkülönítve látszik. A genetikus rész 2 .c fájlban található egy main és egy a genetikus függvényeket tartalmazó állományban. Így egy újabb példára való futtatás alkalmával elég csak a teszteket tartalmazó részt átírni.}
			
			{A genetikus rész legfontosabb függvényeiről a későbbiekben még lesz szó, ezek a mutálás, random kezdőegyedek beállítása, valamint a keresztezés. Azonban emellett más függvények is fontos szerepet játszanak az algoritmus lefutásában. \Aref{fig_egyedkiir} ábrán látható megjelenítésért az \texttt{egyedKiir} függvény a felelős, amely az aktuálisan létrehozott populáció legjobb egyedét hivatott bemutatni a programot futtató felhasználó számára. Majd végül kiírja a jó megoldást is. A kódba bele van építve egy \texttt{joMegoldasTeszt} nevű függvény, ami nincs használatban és a main függvényben is ki van kommentezve. Ez arra szolgál, hogy amikor újabb feladatot akarunk megoldani a programmal és ismerjük a megoldását, akkor esetleges futási hiba esetén ezzel le tudjuk ellenőrizni, hogy a tesztekkel van-e a gond és ha igen akkor melyikkel.}
			
			\Abra{egyedkiir}{A program lefutása}{width=10cm}
			
			{A main függvényben \texttt{joMegoldasTeszt} függvény mellett jelen van a \texttt{Megold} függvény is. Ez a függvény felelős a feladatok megoldásáért. A tesztek alapján beállítottunk egy fitnesz függvényt, mi esetünkben ezt \texttt{hanyatSert}nek nevezzük. A program célja az, hogy a fitnesz értéke 0 legyen, ami akkor valósül meg, ha minden teszt feltételének eleget tesz a program. Ez a program leállási feltétele. A \texttt{Megold} függvény szerkezete igen egyszerű. A POPMERET makróval a program elején beállíthatjuk mennyi egyedet szeretnénk létrehozni az alap populációba és a MEGTART makróval pedig beállíthatjuk mennyi legyen az elit egyedek száma, azaz mennyit tartsunk meg a legjobbak közül. A ciklusba belépés előtt egy kezdeti populációt kell beállítani a programnak. Ezt biztosítja nekünk a \texttt{kezdetiRandom} nevű függvény. Majd ezután léphetünk be a ciklusba, ami a jó megoldásig ismétlődik. A ciklus lényege, hogy feltöltsünk egy temp elnevezésű tömböt, ami minden egyes műveletet POPMERET darabszor hajt végre, majd ebből a már POPMERET*4 elemszámú tömbből egy sorba rendezést követően kiválasztunk MEGTART darab elit egyedet a rendezett tömb elejéről. Ezt követően a továbbiakat úgy választjuk ki, hogy nagy eséllyel a jókat válasszuk, de adott legyen az esély a rosszabb egyedek beválogatására is, hiszen az evolúció során is mindig maradnak fent rosszabb egyedek is. Így áll végül össze a populáció elnevezésű tömb ami ezt a POPMERET darab egyedet tartalmazza, amit később visszatöltünk a ciklusba. \Aref{fig_temp} ábra is ezt a folyamatot hivatott egyszerűen szemléltetni. Jól látszik az ábrán a 4 művelet amiből a ciklus áll. Fontos azonban megjegyezni, hogy a populáció tömböt az első lefutásnál még a \texttt{kezdetiRandom}ból vesszük át teljes egészében és csak a ciklus későbbi lefutásánál töltjük fel a kiválasztott egyedekkel.}
			
			\Abra{temp}{A megoldás lefutásának szemléltetése.}{width=10cm}
			
			{A feladatspecifikus részek jól elkülöníthetők a programban. Itt generálható a feladatban szereplő adatokból a neki megfelelő makrók, hogy későbbiekben egyszerűen egy számként hivatkozhassunk az egyes egyedekre. A programban létrehozott egyedek kritériumoknak való megfelelését a fitnesz függvény értékeli ki. A mi esetünkben ez a \texttt{hanyatSert} elnevezést kapta. Minden Zebra típusú feladvány tartalmaz kritériumokat, amik egy egységes szabályrendszer segítségével leírhatók így akár egy Excel tábla segítségével is könnyen teszt generálható belőlük. Ezeket a teszteket (kritériumokat) fűzi össze a \texttt{hanyatSert} függvény és értékeli ki az egyedek rátermettségét.}

    \section{Egyedreprezentáció és segédfüggvények} % unassigned
        \todo{Hogy reprezentaljuk az egyedet}
        \todo{egyedkiir, sorbarendez, ...}

    \section{Evolúciós mechanizmusok} % unassigned
        \todo{esetleg par felvezeto szo, a kapcsolodo makrok megemlitese (popmeret, megtart)}
        
        \subsection{Random új egyed generálás} % Dani
        
        \Abra{random}{Random egyed generálási módszerek.}{width=12cm}
        
         {Az elso változat még csak feltöltötte az egyedet 0-3-ig a székeket minden tulajdonság estén.}
            
        \subsection{Mutálás} % unassigned
            \todo{Ugyanez. Milyen valtozatok voltak, vannak, részletesen bemutatva}
            
        \subsection{Keresztezés} % Dani
            
            {Keresztezésből alapvetően két fajtát különböztetünk meg. Az egypontos és a kétpontos keresztezést. Az egypontos keresztezés esetében a kromoszómákat véletlenszerűen választott helyen kettévágjuk, majd a felcserélt fél-kromoszómákból újakat hozunk létre.  A kétpontos keresztezés hasonlóan működik, csak ebben az esetben 2 ponton vágjuk el az allélt és a keletkezett 3 darabot fűzzük össze tetszőleges sorrendben.}
                        
            {A mi esetünkben az egyedek allélja egy 2 dimenziós tömb, amelyen egypontos keresztezés került alkalmazásra. Itt 2 fajta választási lehetőség fordul elő. Vagy soronként vágunk vagy a tömb sorait vágjuk ketté. Ebben az esetben az utóbbi eljárás került megírásra. A programok mindegyike egypontos keresztezést használ, ami a sorokat cseréli meg egy bizonyos ponton elvágva a tömböt. \Aref{fig_keresztez-mukodes} ábra szemlélteti a függvény működésének a lényegét. A program során 2 fajta keresztezés került kidolgozásra. Az első verzió egy fix ponton vágta el a tömböt és a 2 felét cserélte meg. A fix pont a számtani közepe a tulajdonságok számainak. Ezzel a módszerrel az a probléma, hogy a folytonos közepén való vágás nem illeszkedik bele a genetikus algoritmus randomitásába. Későbbiekben ez a módszer egy változó segítségével javítva lett azt biztosítva, hogy minden egyedpár különböző helyen legyen elválasztva.}
            
            \Abra{keresztez-mukodes}{A keresztezés mechanizmusa}{width=12cm}
                     
            {A program írása során két fajta keresztezés került kipróbálásra. A crossover 1.0 is úgy lett kitalálva, hogy minden egyeden végezzen keresztezést, viszont az a hibája, hogy mindig 2 egymás mellett lévőn végzi el. Ez viszont nem bizonyult előnyösnek, mivel a populáció tömb rendezve volt így a legjobb egyedek egymás között keresztezve igen nagy eséllyel rosszabb egyedet adtak eredményképpen. Ezt igen egyszerűen ki lehetett javítani azzal, hogy a populáció tömbből véletlenszerűen választunk ki 2 egyedet és azokon végez a program keresztezést. Ez a módszer lehetővé teszi a programnak azt is, hogy 2 egyforma egyedet válasszon ki, ezzel fenntartva a lehetőséget, hogy egy-egy egyed keresztezés nélkül kerüljön be a temp tömbbe. Az 1.0-ás változathoz képest jelentős eltérés, hogy ez a módszer nagy eséllyel hagy olyan egyedeket amiken nem végez keresztezést, mivel nem kerül kiválasztásra. Azonban ez a genetikus algoritmus jegyeit jobban mutatja, mivel 2 véletlenszerűen kiválasztott egyeden végez keresztezést egy véletlenszerűen választott pontban.}
            
            \Forraskod{keresztezes.c}{frame=single , lastline=14}   
            
            {A keresztezés POPMÉRET db alkalommal fut le, azonban a többi evolúciós algoritmushoz hasonlóan innen sem maradt ki a keresztezés a mutált egyedeken , ami szintén POPMÉRET db-szor fut le. Mivel a temp tömb 4*POPMÉRET méretű így a keresztezett egyedek pont a temp felét teszik ki végül, így ebben az algoritmusban is a keresztezés dominál.}

        \subsection{Megold függvény} % unassigned
            \todo{Ugyanez. Milyen valtozatok voltak, vannak, részletesen bemutatva}

    \section{Egyedek kiértékelése} % unassigned
        \todo{Itt is szepen be lehet mutatni, hogy hogyan fejlodott, meg meg lehet mutatni mind az ot-hat tipusra egy peldat}

\chapter{Tesztek} % unassigned
    \todo{Futtatasi eredmenyek, megoldasok megmutatasa, stb.}

\chapter{Kód automatikus generálása} % Dani
    \todo{Miert akarjuk}
    \todo{Hogy csinaltuk}
    \todo{pelda}

\chapter{Összefoglalás} % unassigned
    \todo{Mit csinaltunk roviden}

\chapter*{Hivatkozások}
\addcontentsline{toc}{chapter}{Hivatkozások}

\appendix

\chapter{Mintafejezet}
    \section{Kep betoltese}
        Kep betoltese a \texttt{Abra} makroval az alabbiak szerint. Az elso parameter a fajl neve, ebbol lesz egy fig\_fajlnev cimke, amit ref-ekhez lehet hasznalni. MAsodik parameter a kepalairas, a harmadik a meret.
        \begin{verbatim}
            \Aref{fig_zebra} abran bla bla.
            \Abra{zebra}{Talalo kepalairas}{width=6cm}
        \end{verbatim}

        \Aref{fig_zebra} abran bla bla.
        \Abra{zebra}{Talalo kepalairas}{width=6cm}


    \section{Tablazatok}
        Tablazatot a \texttt{Tablazat} makroval lehet csinalni az alabbiak szerint. Az elso parameter a cimke, ebbol lesz egy tab\_cimke cimke, amit ref-ekhez lehet hasznalni. MAsodik parameter a tablazat cime, a harmadik az oszlopok szerkezete (lasd tabular tutorial), az utolso maga a tablazat tartalma.
        \begin{verbatim}
            Ahogy az \aref{tab_cimke} tablazatban lathato, bla bla bla.
            \Tablazat{cimke}{Tablazat cime}{r||cc|l}
            {
                Elso sor elso cella jobra igazitva & kozepre & kozepre & balra \\
                \hline
                Masodik sor & & yay & much wow\\
                ize & bize & mize & meh... \\
            }
        \end{verbatim}



        Ahogy az \aref{tab_cimke} tablazatban lathato, bla bla bla.
        \Tablazat{cimke}{Tablazat cime}{r||cc|l}
        {
            Elso sor elso cella jobra igazitva & kozepre & kozepre & balra \\
            \hline
            Masodik sor & & yay & much wow\\
            ize & bize & mize & meh... \\
        }


    \section{Forraskodok beemelese}
        Forraskodot vagy a \texttt{Forraskod} makroval lehet betolteni a fajlbol, ahol az elso parameter a fajl neve, a masodik tovabbi opciok, pl hogy melyik sortol melyik sorig, stb. A masik lehetoseg, hogy a kodba keruljon be az alabbiak szerint:

        \begin{verbatim}
            \Forraskod{ize.c}{frame=single,lastline=4}
        \end{verbatim}

        \Forraskod{ize.c}{frame=single,lastline=4}

        \begin{verbatim}
            \begin{lstlisting}[frame=single, language=C]
                printf("Hello world\n");
                if(whatever){
                    return 1;
                } else do {
                    tanuljmegindentalni();
                } while (i<5);
            \end{lstlisting}
        \end{verbatim}
        
        \begin{lstlisting}[frame=single, language=C]
            printf("Hello world\n");
            if(whatever){
                return 1;
            } else do {
                tanuljmegindentalni();
            } while (i<5);
        \end{lstlisting}




    

\end{document}
