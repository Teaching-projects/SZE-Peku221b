\documentclass[12ppt,a4paper,oneside]{report}

\usepackage{makrok}

\author{Szili Dániel, Schöffer Fruzsina, Tóth Sándor Balázs, Varga Máté\\\ \\Témavezető: Dr. Hegyháti Máté}
\title{Zebra típusú logikai rejtvények megoldása evolúciós algoritmussal}

\begin{document}

\maketitle

\tableofcontents

\chapter{Bevezetés} % unassigned
    \todo{Absztrakt bovebben, szoveges tartalomjegyzek}

\chapter{Zebra rejtvények} % Balázs
    \todo{Egy bevezeto mondat, + hogy melyik alfejezetben mi lesz}
    
    \section{Történet és szerkezet} % Balázs
        \todo{Miert zebra, mikbol all a rejtveny, Einstein peldajabol reszlet akar}

    \section{Megoldhatóság, egyértelműség} % Balázs
        \todo{Pici peldakon bemutatni, hogy ha rosszak a szabalyok, akkor lehet nincs megoldas, vagy ha keves a szabaly, akkor lehet tobb megoldas is van. Egy nagyon apro (3 szek, 2 tulajdonsag mondjuk) pelda kitalalasa es megoldasa par lepesben. }

    \section{Megoldó módszerek} % Balázs
        \todo{Irodalomban talalhato modszerek, 2 mondat roluk, hivatkozasok}

\chapter{Evolúciós algoritmusok} % Balázs
    \todo{Tortenetuk, hivatkozasok}
    \todo{Altalanos felepitesuk}
    \todo{Akar par szo arrol, mi mindenre alkalmaztak oket, hivatkozasok}

\chapter{Evolúciós algoritmus Zebra rejtvények megfejtésére} % unassigned
    \todo{Par mondat az alapveto elgondolasrol, hogy melyik fejezetben mirol lesz szo}

    \section{Kódszerkezet} % Dani
        \todo{Hogy van szervezve a kod, milyen fuggvenyek vannak,azok mikert fognak felelni roviden.}

    \section{Egyedreprezentáció és segédfüggvények} % unassigned
        \todo{Hogy reprezentaljuk az egyedet}
        \todo{egyedkiir, sorbarendez, ...}

    \section{Evolúciós mechanizmusok} % unassigned
        \todo{esetleg par felvezeto szo, a kapcsolodo makrok megemlitese (popmeret, megtart)}
        
        \subsection{Random új egyed generálás} % Dani
            \todo{Milyen volt az elso valtozat, hogy lett fejlesztve}
            
        \subsection{Mutálás} % unassigned
            \todo{Ugyanez. Milyen valtozatok voltak, vannak, részletesen bemutatva}
            
        \subsection{Keresztezés} % Dani
            
            {Keresztezésből alapvetően két fajtát különböztetünk meg. Az egypontos és a kétpontos keresztezést. Az egypontos keresztezés esetében a kromoszómákat véletlenszerűen választott helyen kettévágjuk, majd a felcserélt fél-kromoszómákból újakat hozunk létre. \Aref{fig_keresztez-mukodes} ábra szemlélteti a függvény működésének a lényegét. A kétpontos keresztezés hasonlóan működik, csak ebben az esetben 2 ponton vágjuk el az allélt és a keletkezett 3 darabot fűzzük össze tetszőleges sorrendben. }
            
            {A mi esetünkben az egyedek allélja egy 2 dimenziós tömb, amelyen egypontos keresztezés került alkalmazásra. Itt 2 fajta választási lehetőség fordul elő. Vagy soronként vágunk vagy a tömböt szedjük ketté. Ebben az esetben az utóbbi eljárás került megírásra. A programok mindegyike egypontos keresztezést használ, ami a sorokat cseréli meg egy bizonyos ponton elvágva a tömböt. A program során 2 fajta keresztezés került kidolgozásra. Az első verzió egy fix ponton vágta el a tömböt és a 2 felét cserélte meg. A fix pont a számtani közepe a tulajdonságok számainak. Ezzel a módszerrel az a probléma, hogy a folytonos közepén való vágás nem illeszkedik bele a genetikus algoritmus randomitásába. Későbbiekben ez a módszer egy változó segítségével javítva lett azt biztosítva, hogy minden egyedpár különböző helyen legyen elválasztva.}
            
            {A program írása során két fajta keresztezés került kipróbálásra. \Aref{fig_keresztez-egyedvalasztas} ábrán látható crossover 1.0 is úgy lett kitalálva, hogy minden egyeden végezzen keresztezést, viszont az a hibája, hogy mindig 2 egymás mellett lévőn végzi el. Ez viszont nem bizonyult előnyösnek, mivel a populáció tömb rendezve volt így a legjobb egyedek egymás között keresztezve igen nagy eséllyel rosszabb egyedet adtak eredményképpen. \Aref{fig_keresztez-egyedvalasztas} ábrára visszautalva, ezt igen egyszerűen ki lehetett javítani azzal, hogy a populáció tömbből véletlenszerűen választunk ki 2 egyedet és azokon végez a program keresztezést. Ez a módszer lehetővé teszi a programnak azt is, hogy 2 egyforma egyedet válasszon ki, ezzel fenntartva a lehetőséget, hogy egy-egy egyed keresztezés nélkül kerüljön be a temp tömbbe. Az 1.0-ás változathoz képest jelentős eltérés, hogy ez a módszer nagy eséllyel hagy olyan egyedeket amiken nem végez keresztezést, mivel nem kerül kiválasztásra. Azonban ez a genetikus algoritmus jegyeit jobban mutatja, mivel 2 véletlenszerűen kiválasztott egyeden végez keresztezést egy véletlenszerűen választott pontban.}
            
            {A keresztezés POPMÉRET db alkalommal fut le, azonban a többi evolúciós algoritmushoz hasonlóan innen sem maradt ki a keresztezés a mutált egyedeken , ami szintén POPMÉRET db-szor fut le. Mivel a temp tömb 4*POPMÉRET méretű így a keresztezett egyedek pont a temp felét teszik ki végül, így ebben az algoritmusban is a keresztezés dominál.}
        
            \Abra{keresztez-mukodes}{A keresztezés mechanizmusa}{width=6cm}
            \Abra{keresztez-egyedvalasztas}{Keresztezési módok kódja}{width=6cm}

        \subsection{Megold függvény} % unassigned
            \todo{Ugyanez. Milyen valtozatok voltak, vannak, részletesen bemutatva}

    \section{Egyedek kiértékelése} % unassigned
        \todo{Itt is szepen be lehet mutatni, hogy hogyan fejlodott, meg meg lehet mutatni mind az ot-hat tipusra egy peldat}

\chapter{Tesztek} % unassigned
    \todo{Futtatasi eredmenyek, megoldasok megmutatasa, stb.}

\chapter{Kód automatikus generálása} % Dani
    \todo{Miert akarjuk}
    \todo{Hogy csinaltuk}
    \todo{pelda}

\chapter{Összefoglalás} % unassigned
    \todo{Mit csinaltunk roviden}

\chapter*{Hivatkozások}
\addcontentsline{toc}{chapter}{Hivatkozások}

\appendix

\chapter{Mintafejezet}
    \section{Kep betoltese}
        Kep betoltese a \texttt{Abra} makroval az alabbiak szerint. Az elso parameter a fajl neve, ebbol lesz egy fig\_fajlnev cimke, amit ref-ekhez lehet hasznalni. MAsodik parameter a kepalairas, a harmadik a meret.
        \begin{verbatim}
            \Aref{fig_zebra} abran bla bla.
            \Abra{zebra}{Talalo kepalairas}{width=6cm}
        \end{verbatim}

        \Aref{fig_zebra} abran bla bla.
        \Abra{zebra}{Talalo kepalairas}{width=6cm}


    \section{Tablazatok}
        Tablazatot a \texttt{Tablazat} makroval lehet csinalni az alabbiak szerint. Az elso parameter a cimke, ebbol lesz egy tab\_cimke cimke, amit ref-ekhez lehet hasznalni. MAsodik parameter a tablazat cime, a harmadik az oszlopok szerkezete (lasd tabular tutorial), az utolso maga a tablazat tartalma.
        \begin{verbatim}
            Ahogy az \aref{tab_cimke} tablazatban lathato, bla bla bla.
            \Tablazat{cimke}{Tablazat cime}{r||cc|l}
            {
                Elso sor elso cella jobra igazitva & kozepre & kozepre & balra \\
                \hline
                Masodik sor & & yay & much wow\\
                ize & bize & mize & meh... \\
            }
        \end{verbatim}



        Ahogy az \aref{tab_cimke} tablazatban lathato, bla bla bla.
        \Tablazat{cimke}{Tablazat cime}{r||cc|l}
        {
            Elso sor elso cella jobra igazitva & kozepre & kozepre & balra \\
            \hline
            Masodik sor & & yay & much wow\\
            ize & bize & mize & meh... \\
        }


    \section{Forraskodok beemelese}
        Forraskodot vagy a \texttt{Forraskod} makroval lehet betolteni a fajlbol, ahol az elso parameter a fajl neve, a masodik tovabbi opciok, pl hogy melyik sortol melyik sorig, stb. A masik lehetoseg, hogy a kodba keruljon be az alabbiak szerint:

        \begin{verbatim}
            \Forraskod{ize.c}{frame=single,lastline=4}
        \end{verbatim}

        \Forraskod{ize.c}{frame=single,lastline=4}

        \begin{verbatim}
            \begin{lstlisting}[frame=single, language=C]
                printf("Hello world\n");
                if(whatever){
                    return 1;
                } else do {
                    tanuljmegindentalni();
                } while (i<5);
            \end{lstlisting}
        \end{verbatim}
        
        \begin{lstlisting}[frame=single, language=C]
            printf("Hello world\n");
            if(whatever){
                return 1;
            } else do {
                tanuljmegindentalni();
            } while (i<5);
        \end{lstlisting}




    

\end{document}
