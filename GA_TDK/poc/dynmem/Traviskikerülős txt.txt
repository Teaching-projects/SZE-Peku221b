#include <iostream>
#include <cstdlib>
using namespace std;

#define SZEK 4
#define TULAJDONSAG 5
#define POPMERET 100
#define MEGTART 10

#define SHIRT 0
    #define BLACK 00
    #define BLUE 01
    #define GREEN 02
    #define RED 03

#define NAME 1
    #define DANIEL 10
    #define JOSHUA 11
    #define NICHOLAS 12
    #define RYAN 13

#define MOVIE 2
    #define ACTION 20
    #define COMEDY 21
    #define HORROR 22
    #define THRILLER 23

#define SNACK 3
    #define CHIPS 30
    #define COOKIES 31
    #define CRACKERS 32
    #define POPCORN 33

#define AGE 4
    #define ELEVEN 40
    #define TWELVE 41
    #define THIRTEEN 42
    #define FOURTEEN 43


const char *TULNEVEK[TULAJDONSAG][SZEK] = {
        {"black","blue","green","red"},
        {"Daniel", "Joshua", "Nicholas", "Ryan"},
        {"action", "comedy", "horror", "thriller"},
        {"chips", "cookies", "crackers", "popcorn"},
        {"11", "12", "13", "14"}
    };

struct gen{
    int allel[TULAJDONSAG][SZEK];
    int megsert;
};

struct person {
        int property;
        int value;
};

struct onepersonrule {
    struct person first;
};

struct twopersonrule {
    struct person first;
    struct person second;
};

struct threepersonrule {
    struct person first;
    struct person second;
    struct person third;
};

struct positionrule {
    struct person first;
    int hely;
};

int hanyasSzek(struct gen egyed,int property, int value){
    int sz;
    for(sz=0;sz<SZEK;sz++)
        if (egyed.allel[property][sz]==value) return sz;
    return 0;
}
   
int testAtTheEnd(struct onepersonrule attheend[3]){
    int i, position, megsert=0;
    for (i=0;i<3;i++){
        position=hanyasSzek(attheend[i].first.property, attheend[i].first.value);
        if (position>0 && position<SZEK-1) megsert++;
    }
    return megsert;
}

int testExactlyToTheLeft(struct twopersonrule exactlyleft[1]){
    int i, position1, position2, megsert=0;
    for (i=0;i<1;i++){
        position1=hanyasSzek(exactlyleft[i].first.property, exactlyleft[i].first.value);
        position2=hanyasSzek(exactlyleft[i].second.property, exactlyleft[i].second.value);
        if !(position1==position2-1) megsert++;
    }
    return megsert;
}

int testExactlyToTheRight(struct twopersonrule exactlyright[1]){
    int i, position1, position2, megsert=0;
    for (i=0;i<1;i++){
        position1=hanyasSzek(exactlyright[i].first.property, exactlyright[i].first.value);
        position2=hanyasSzek(exactlyright[i].second.property, exactlyright[i].second.value);
        if !(position2==position1-1) megsert++;
    }
    return megsert;
}

int testSomewhereToTheLeft(struct twopersonrule somewhereleft[1]){
    int i, position1, position2, megsert=0;
    for (i=0;i<1;i++){
        position1=hanyasSzek(somewhereleft[i].first.property, somewhereleft[i].first.value);
        position2=hanyasSzek(somewhereleft[i].second.property, somewhereleft[i].second.value);
        if !(position1<position2) megsert++;
    }
    return megsert;
}

int testSameperson (struct twopersonrule sameperson[2]){
    int i, position1, position2, megsert=0;
    for (i=0;i<2;i++){
        position1=hanyasSzek(sameperson[i].first.property, sameperson[i].first.value);
        position2=hanyasSzek(sameperson[i].second.property, sameperson[i].second.value);
        if !(position1=position2) megsert++;
    }
    return megsert;
}

int testPosition (struct positionrule position[2]){
    int i, megsert=0;
    for (i=0;i<2;i++){
        if !(hely=hanyasSzek(attheend[i].first.property, attheend[i].first.value)) megsert++;
    }
    return megsert;
}

int testSomewhereBetween (struct threepersonrule between[3]){
    int i, position1, position2, position3, megsert=0;
      for (i=0;i<3;i++){
        position1=hanyasSzek(between[i].first.property, between[i].first.value);
        position2=hanyasSzek(between[i].second.property, between[i].second.value);
        position3=hanyasSzek(between[i].third.property, between[i].third.value);
        if !(position2<position1 && position1<position3) megsert++;
      }
    return megsert;
}

int fitness(){
	int megsert=0;
    megsert+=testSomewhereBetween(*kozott);
    megsert+=testExactlyToTheLeft(*balpont);
    megsert+=testExactlyToTheRight(*jobbpont);
    megsert+=testPosition(*pozicio);
    megsert+=testSameperson(*ugyanaz);
    megsert+=testSomewhereToTheLeft(*balvhol);
    megsert+=testAtTheEnd(*vegen);
    return megsert;
}

struct gen kezdetiRandom(){
    struct gen egyed;
    int t,sz;
    for (t=0;t<TULAJDONSAG;t++){
		for(sz=0;sz<SZEK;sz++){
			egyed.allel[t][sz]=t*10+sz;
        }
    }
    int i;
    int j;
    int tmp;
    for (t=0;t<TULAJDONSAG;t++){
		for(i=SZEK-1;i>=1;i--){
            j=rand()%(i+1);
            tmp=egyed.allel[t][i];
            egyed.allel[t][i]=egyed.allel[t][j];
            egyed.allel[t][j]=tmp;
        }
    }
    egyed.megsert=fitness();
    return egyed;    
}

struct gen kezdetiRandom2(){
    struct gen egyed;
    int sz,t,db,index;
    int van[SZEK];
    for (t=0;t<TULAJDONSAG;t++){
		for(sz=0;sz<SZEK;sz++){
			van[sz]=0;
		}
		for(sz=0;sz<SZEK;sz++){
			db=rand()%(SZEK-sz);
            index=0;
            while(van[index]==1) index++;
			for(;db!=0;index++){
				if (van[index]==0){
					db--;
				}
			}
			van[index]=1;
			egyed.allel[t][sz]=t*10+index;

		}
	}
	egyed.megsert=fitness();
	return egyed;
}

void egyedKiir(struct gen egyed){
    int sz,t;
    cout << ("\n");
    for(t=0;t<TULAJDONSAG;t++){
        cout<< ("|");
        for(sz=0;sz<SZEK;sz++){
            cout << (TULNEVEK[t][egyed.allel[t][sz]]);
        }
        cout << ("|\n");
    }
    cout << ("\n\n");
}

//Rendezés (növekvõ)
void Rendezes(struct gen populacio[], int meret){
	struct gen X;
    int i,j;
	for (i=1;i<meret;i++){
 		X=populacio[i];
  		j=i-1;
  		while((j>=0) && (populacio[j].megsert>X.megsert)){
  			populacio[j+1]=populacio[j];
  			j=j-1;
  		}
        populacio[j+1]=X;
	}
}

struct gen Mutal(struct gen egyed){
    struct gen uj=egyed;
    int hanyatmutal=rand()%5+1;
    int i;
    int tmp;
    for(i=0;i<hanyatmutal;i++){
        int cseret=rand()%TULAJDONSAG;
        int csere1sz=rand()%SZEK;
        int csere2sz=rand()%SZEK;
        while (csere1sz==csere2sz) {
            csere2sz=rand()%SZEK;
        }
        tmp=uj.allel[cseret][csere1sz];
        uj.allel[cseret][csere1sz]=uj.allel[cseret][csere2sz];
        uj.allel[cseret][csere2sz]=tmp;
    }
    uj.megsert=fitness();
    return uj;
}

struct gen Keresztez(struct gen egyed1, struct gen egyed2){
	int sz,t;
	struct gen egyed;
    int hol=rand()%TULAJDONSAG;
	for (t=0;t<TULAJDONSAG;t++){
		if (t<hol){
            for (sz=0;sz<SZEK;sz++){
                egyed.allel[t][sz]=egyed1.allel[t][sz];
            }
        } else {
			for (sz=0;sz<SZEK;sz++){
               egyed.allel[t][sz]=egyed2.allel[t][sz];
			}
		}
	}
    egyed.megsert=fitness();
    return egyed;
}

int main(){
    struct gen populacio[POPMERET];
    int i;
    for(i=0;i<POPMERET;i++) {
            populacio[i]=kezdetiRandom();
    }
    struct gen temp[POPMERET*4];
    int k;
    int j;

    for(i=0;populacio[0].megsert!=0;i++){
        printf("Generacio %2d: ",i);
        egyedKiir(populacio[0]);
        k=0;
        for (j=0;j<POPMERET; j++){
            temp[k]=populacio[j];
            k++;
        }
        for (j=0;j<POPMERET; j++){
            temp[k]=Mutal(populacio[j]);
            k++;
        }
        for (j=0;j<POPMERET;j++){
           int x=rand()%POPMERET;
           int y=rand()%POPMERET;
           temp[k]=Keresztez(populacio[x],populacio[y]);
           k++;
         }
        for (j=0;j<POPMERET;j++){
           int x=rand()%POPMERET;
           int y=rand()%POPMERET;
           temp[k]=Keresztez(temp[x+POPMERET],temp[y+POPMERET]);
           k++;
         }
          struct onepersonrule *vegen = new struct onepersonrule[3];
    *vegen = struct onepersonrule attheend[3] =
    {
        {NAME,JOSHUA},
        {SNACK,COOKIES},
        {MOVIE,THRILLER}

    };
	struct twopersonrule *balpont = new struct twopersonrule[1];
	*balpont = struct twopersonrule exactlyleft[1] =
	{
		{ int fajl[32];
        std::string line_;
        ifstream file_("fajl.txt");
        if(file_.is_open()){
            getline(file_,line_);
            file_.close();
        }
    else
    exit(EXIT_FAILURE);
    std::cin.get();
        };
	};
	struct twopersonrule *jobbpont = new struct twopersonrule[1];
	*jobbpont = struct twopersonrule exactlyright[1] =
	{
		{ MOVIE,COMEDY,SNACK,CRACKERS };
	};
	struct twopersonrule *balvhol = new struct twopersonrule[1];
	*balvhol = struct twopersonrule somewhereleft[1] =
	{
		{ AGE,ELEVEN,SHIRT,BLACK };
	};
	struct positionrule *pozicio = new struct positionrule[1];
	*pozicio = struct positionrule position[2] =
	{
		{ AGE,FOURTEEN,3 },
		{ SHIRT,GREEN,1 }
	};
	struct threepersonrule *kozott = new struct threepersonrule[3];
	*kozott = struct threepersonrule between[3] =
	{
		{ AGE,THIRTEEN,SHIRT,RED,MOVIE,ACTION },
		{ SNACK,POPCORN,SHIRT,RED,NAME,NICHOLAS },
		{ NAME,JOSHUA,NAME,NICHOLAS,NAME,DANIEL }
	};
	struct twopersonrule *ugyanaz = new struct twopersonrule[2];
	*ugyanaz = struct twopersonrule sameperson[2] =
	{
		{ NAME,JOSHUA,MOVIE,HORROR },
		{ NAME,DANIEL,MOVIE,THRILLER }
	};
    fitness();

        Rendezes(temp,4*POPMERET);
        for (j=0; j<MEGTART;j++){
            populacio[j]=temp[j];
        }
        for (j=MEGTART;j<POPMERET;j++){
			k=rand()%((int) (POPMERET*1.2));
			if (k<POPMERET){
                populacio[j]=temp[j];
			} else {
                populacio[j]=temp[POPMERET+j];
			}
		}
    }
    cout << ("******************************\n");
    egyedKiir(populacio[0]);
    return 0;
}
