\documentclass[12pt,a4paper,twoside, openright]{report}

\usepackage{makrok}
\usepackage{listingsutf8}
\usepackage{color}

\author{Papp Ádám, Sós Nikolett\\Mérnök Informatikus BSc, I. évfolyam\\\ \\Témavezető: Ősz Olivér, doktorandusz\\Széchenyi István Egyetem, GIVK, Informatika Tanszék}
\title{Logikai feladványok megoldása \\korlátprogramozással}

\begin{document}

\maketitle


\chapter*{Kivonat}

    A vizsgált feladatok az „Einstein fejtörője” néven ismert logikai feladvány, és annak különböző változatai.
    Ezekben a feladatokban adottak bizonyos személyek vagy objektumok, ezeknek néhány tulajdonságuk, melyek adott értékeket vehetnek fel.
    A feladatok hasonlítanak a szakirodalomban hozzárendelési feladatként ismert feladatosztályhoz, azzal a különbséggel, hogy nem az optimális hozzárendelést keressük egy adott szempont szerint, hanem speciális korlátozások vannak megadva a hozzárendelésre, és olyan megoldást keresünk, ami ezeket a feltételeket kielégíti.
    Míg a hozzárendelési feladatok megoldására a szakirodalomban léteznek hatékony algoritmusok, a logikai feladványok, különösen a korlátozások leírása valamilyen általánosabb modellezési módszert igényel.

    Az általunk választott módszer a korlátprogramozás (constraint programming), ami egy modellezési és egy megoldási módszertan is egyben.
    Az utóbbi néhány évben egyre elterjedtebbé vált a korlátprogramozás használata különböző optimalizálási és kielégíthetőségi feladatok megoldásában.

    Munkánk során megvizsgáltuk a logikai feladványok szerkezetét, összegyűjtöttük a korlátozások fajtáit.
    Különböző módokon modelleztük a korlátozásokat, és összehasonlítottuk őket megoldási teljesítmény szempontjából.
    Többféle megoldó szoftver teljesítményét is összevetettük egymással, és azonosítottuk, hogy az egyes megoldók hatékonyságát hogyan befolyásolta a használt modellezési módszer.

    \textbf{Kulcsszavak}: logikai fejtörők, korlátprogramozás, hozzárendelési feladat


\tableofcontents


\chapter{Bevezetés}

    Dolgozatunkban az „Einstein-féle” fejtörőkként ismertté vált logikai feladványok megoldásával foglalkozunk.
    A feladványok modellezéséhez használt korlátprogramozási módszert és a MiniZinc nyelvet az 1.1. alfejezetben mutatjuk be.
    A vizsgált feladatok bemutatása az 1.2. alfejezetben olvasható.
    A 2. fejezetben példákon szemléltetjük a feladatok néhány lehetséges modellezését és ismertetjük az összehasonlító tesztek eredményeit.
    A 3. fejezetben pedig a redundáns megkötések kiszűrésére vonatkozó eredmények találhatók.

\section{Korlátprogramozás bemutatása} 

    A feladatunkat úgynevezett korlátprogramozással oldottuk meg.
    Ennek a módszernek a legkorábbi verziója – a Sketchpad – 1963-ra tehető és Ivan Sutherland nevéhez fűződik\cite{sketchpad}.
    Az 1980-as évektől egyre keresettebb lett, és mivel a logikai programozást szerették volna kiterjeszteni, így sok helyen korlát-logikai programozásként hivatkoznak rá.
    Az első praktikus verziókat – amiket üzleti célokra alkottak és már eladásra is bocsájtottak – az 1990-es években készítették.

    A projektünkben a MiniZinc nevű grafikus szerkesztő programot használtuk – magát a nyelvet is így hívják –, aminek a fordítója az mzn2fzn, amely FlatZinc-re fordítja a MiniZinc modellt.
    Ezt a legtöbb megoldó által támogatott formátumú fájlt adja tovább a megoldónak, ami végül kiadja a megoldást.
    Az egyik legnépszerűbb megoldó a Gecode, melynek fő alkotója Christian Schulte\cite{gecode}.
    A munkát 2002-ben kezdték meg, 2005 decemberében adták ki az első verziót, és onnantól kezdve több évben is aranyérmes lett az Association for Constraint Programming által rendezett versenyeken.
    A Gecode-on kívül más megoldókkal is képes együttműködni a MiniZinc, ilyen például a Gurobi, a Chuffed és a CBC.
    A megoldók általános működését legkönnyebben egy feladaton keresztül lehet szemléltetni.
    A feladványt a szakirodalomban „négyszín tételként” szokták említeni.
    Adottak bizonyos országok és ezeket úgy kell kiszínezni adott számú színnel, hogy a szomszédos területek ne legyenek azonosak.
    A modell elején megadjuk a használt színek számát és külön ki van emelve, hogy a megoldás során is ezeket vegyék fel az egységek.
    A szomszédsági mátrixot – ami egyben a feltételek listája is itt esetünkben – kikötések van megadva.
    A legprimitívebb mód erre az, hogy a szomszédok meg vannak adva páronként, amiknek más és más értéket kell felvenniük, azaz két egymás mellett lévő rész nem lehet egyenlő tulajdonságú.

    \Abra{terkepszinezes}{}{width=8cm}

    A megoldó úgy dolgozik, hogy kiválaszt egy változót – a példában egy országot – és beállítja egy lehetséges értékre – színre.
    Ezután a korlátozások alapján következtetve csökkenti a többi változó lehetséges értékkészletét.
    Ezt a műveletet propagációnak nevezzük.
    A példában ez azt jelenti, hogy a szomszédos területeknél kizárja azt a lehetőséget, amit már felhasznált, így már csak a megmaradt színekből választhat.
    Ha a propagáció során egy változó lehetséges értékkészlete üressé válik, akkor a megoldó visszavonja a legutolsó értékadást, és az adott értéket kizárja a változó értékkészletéből, mert ellentmondáshoz vezet.
    Ezután egy másik értéket ad neki, vagy egy új változót választ ki.
    Amikor minden változónak sikerült értéket adni, akkor az egy lehetséges megoldása a feladatnak.
    Természetesen nem csak egy megoldás létezhet, ha például a piros és a fekete szín fel van cserélve egymással, akkor az már másik megoldásnak fog számítani.
    Ha több megoldásra vagyunk kíváncsiak, folytathatjuk a keresést az utolsó értékadás visszavonásával.
    A korlátprogramozásnak ez egy hatalmas előnye más módszerekhez képest, hogy az összes lehetséges megoldást kiadja nekünk, nem pedig csak egyet.
    A módszer optimalizálásra is használható, ahol a megoldások értékét egy célfüggvény adja meg.
    A keresés során egy további korlátozást kell figyelembe venni: hogy a megoldás értéke az eddig megtalált megoldásoknál jobb legyen.


\section{Logikai feladványok bemutatása}

    A címben lévő logika szóról az első érdemleges információnk Arisztotelésztől származik.
    Fontos megjegyezni, hogy nem tartotta külön tudománynak, csupán egy eszközként tekintett rá más szakirányokhoz.
    Szerinte ennek az elsajátítása ugyanannyira nem „tudatos”, mint az anyanyelv megtanulása.\cite{logic}
    A összes vizsgált feladatunk a logikára épül, ezért is kapták a „logikai feladvány” nevet.
    Mi részletesebben az „Einstein-féle” esetekkel\cite{logicpuzzles} dolgoztunk.
    Ezekben a feladatokban adottak személyek és hozzájuk több személyes tulajdonság vagy tárgy, melyek mindegyike csak egy bizonyos emberhez tartozik, de hogy melyik kihez, annak a meghatározása maga a feladat.
    A feladvány megad néhány állítást a személyekről és tulajdonságaikról, melyekből levezethető a helyes hozzárendelés.
    A leghíresebb feladata a következő.
    Adva van öt különböző színű ház egymás mellett, melyekben más és más nemzetiségű lakó él.
    Mind az öt ház tulajdonosa egy bizonyos italt iszik, egy bizonyos márkájú cigarettát vesz, és egy adott háziállata van.
    Mindegyik tulajdonos más háziállatot tart, más márkájú cigarettát szív, és más italt fogyaszt.
    A mi dolgunk, hogy kitaláljuk a kikötések alapján, hogy mi a helyes megoldás.

    A hozzárendelési feladatok nagyon hasonlítanak az általunk vizsgált feladatokhoz, de sok dologban el is térnek tőlük.
    Az egyik talán legszembetűnőbb különbség, hogy ezek a modellek optimalizálásra lettek kitalálva, ahol valamilyen célfüggvény segítségével a legjobb megoldást keressük a sok lehetőségből.
    A kikötések itt egyáltalán nem szerepelnek, minden hozzárendelés egy lehetőség, maximum csak azt szabják meg, hogy nem lehet mindent mindenhez hozzárendelni.
    A legismertebb ilyen modell a magyar módszer\cite{magyarmodszer}.
    Ilyen feladatra példa a gép-hozzárendelési feladat.
    Adott meghatározott számú gép és ugyanannyi független munka.
    Bármelyik gép bármelyik munkát képes elvégezni.
    Ismertek a gépek adott munkákra vonatkozó költségei.
    A feladat az, hogy minden géphez rendeljünk pontosan egy munkát úgy, hogy az összköltség minimális legyen.

    Einstein feladatát egyes források szerint az emberiség csupán 2 százaléka képes megoldani, ami nem tudományosan alátámasztott adat, de azt mindenképpen kifejezi, hogy bizony jó logikára van szükség hozzá.
    Ez is bizonyítja, hogy egyes feladatoknál ahhoz, hogy megkapjuk az eredményt sok időt és energiát kell belefektetni a munkába.
    Éppen ezért vizsgáltuk azt, hogy hogyan lehet az ilyen feladványok megoldását számítógépes segítséggel meghatározni.
		
\chapter{Feladatok modellezése korlátprogramozással}



\section{Gardens feladatmegoldás} 

    A munkánk során részletesen bizonyos előre „legyártott” feladatokat vizsgáltunk.
    Az első ilyen neve „Gardens”, azaz „Kertek”, amit az Einstein-féle logikai feladványokhoz sorolnak\cite{gardens}.
    Adott 5 barát, akiknek a kertjei egymás mellett helyezkednek el.
    Ezeken a területeken 12-féle növényből termesztenek 4-et fejenként.
    Azt is tudjuk, hogy ezekből a terményekből 4 gyümölcs, 4 zöldség és 4 virág van.
    Azt, hogy ki melyik kertben dolgozik és azt, hogy mit tartalmaznak ezek, azt kikötések sora után tudjuk csak meg, aminek a végeredményét az alábbi kép szemlélteti.


    \Abra{gardens}{}{width=10cm}

\subsection{Bináris mátrix}

    Először is az általunk használt parancsokat mutatnám be a kikötések fajtái alapján a megoldásunk első verzióján.
    Itt bináris mátrix segítségével dolgoztunk, azaz, ha megtalálható valami a kertben, akkor a helyére 1-est, ha nem akkor 0-át raktunk a táblázatba.
    A tulajok egy külön tömbben vannak tárolva, melyeket összekötöttünk a kertekkel.
	
	\begin{table}
		\centering
		\caption{}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline 
			& Hank & Sam & Paul & Zick & Luke \\ 
			\hline 
			alma & 1 & 0 & 0 & 0 & 0 \\ 
			\hline 
			körte & 1 & 0 & 0 & 0 & 1 \\ 
			\hline 
			mogyoró & 0 & 0 & 0 & 0 & 1 \\ 
			\hline 
			cseresznye & 1 & 1 & 0 & 0 & 0 \\ 
			\hline 
			sárgarépa & 0 & 0 & 1 & 0 & 0 \\ 
			\hline 
			petrezselyem & 0 & 0 & 0 & 0 & 1 \\ 
			\hline 
			tök & 0 & 0 & 1 & 0 & 1 \\ 
			\hline 
			hagyma & 0 & 1 & 1 & 0 & 0 \\ 
			\hline 
			őszirózsa & 0 & 0 & 0 & 1 & 0 \\ 
			\hline 
			rózsa & 1 & 1 & 1 & 1 & 0 \\ 
			\hline 
			tulipán & 0 & 1 & 0 & 1 & 0 \\ 
			\hline 
			liliom & 0 & 0 & 0 & 1 & 0 \\ 
			\hline 
		\end{tabular}
	\end{table}
     
    A legfontosabb, hogy minden utasítást „constraint”-el kell kezdeni.
    A szó maga is nagyon jól szemlélteti, hogy ami mögé van írva, azt úgymond „kikényszerítjük”, hogy tartsa be a munka során.
    Első dolgunk a változók deklarálása, méretének megadása és a tömbök létrehozása volt.

    Első kettőt az „int” és „set of int”, utóbbit az „array” kulcsszóval tettük meg, ami után megadtuk a tömb méretét, és azt, hogy milyen értékeket vegyenek fel az elemei.

    \Abra{mtx_declaration}{}{width=12cm}

    A képeken is jól látszik, hogy Zick például csak virágokat termel, míg Hank-nél vagy 
    Sam-nél mind három fajta termény megtalálható, tehát nagyon különbözőek a kertek.

    Direkt ezekre az esetekre áll rendelkezésünkre az „alldifferent”, ami kifejezi, hogy mint a kertek, mint a tulajok csak és kizárólag egyszer szerepelnek és eltérnek egymástól.

    \Abra{alldifferent1}{}{width=8cm}

    A leírásban sok olyan kikötés szerepel, ami kijelenti, hogy mi hányszor szerepel.
    Ennek három speciális esetét különböztettük meg.
    Az első mikor konkrétan megadják, hogy melyik kertben vagy melyik tulaj termeszti/nem termeszti az adott dolgot, de eme módon akár a tulajt is megadhatják.
    Ilyenkor egyszerűen csak megadjuk az adott cella értékét.

    \begin{equation}
    termeszt_{12,3}=0 
    \end{equation}

    A második mikor csak annyit tudunk, hogy az adott növényt hányszor termeljük.
    Ilyen esetekben azt az előnyt használtuk ki, hogy mivel a táblázatunkban számok vannak, így lehet sima összeadás műveletet használni, így ilyenkor a sorösszegeket adtuk meg neki.
    
	\begin{equation}
    \sum_{k\in Kertek} termeszt_{1,k} =1 
    \end{equation}

    A harmadik pedig nagyon hasonlít a másodikhoz, de a szövegben valamilyen formában még jobban hangsúlyozza az állítást.
    Ilyen esetekre van az „exactly” a kulcsszó a gyűjteményben , aminek konkrét felépítési kritériuma van.

    \Abra{exactly}{}{width=14cm}

    Végül, de nem utolsó sorban van még egy kikötési forma amit használtunk, de ez nem volt elég hatékony megoldás, melyről a következő alfejezetben lesz szó.

    \begin{equation}
        \sum_{z\in Zoldsegek} termeszt_{z,t} = 3 \qquad \forall t\in Tulaj: tulaj_{t} = 4
    \end{equation}
    % ezt mutassátok meg minizinc kóddal is
    % amit viszont lehet matematikai jelöléssel, azt írjátok át arra
    % a MiniZinc és Csharp forráskódok pedig \lst(input)listing paranccsal legyenek formázva
    

\subsection{Where helyett implikáció}

    Ha a „forall”-on belül olyan „where” feltétellel szűrünk, ami a változók értéke alapján szűri a korlátozást, akkor amíg nincs meghatározva ezen változók értéke, addig ezek a korlátozások nem vesznek részt a propagációban sem.
    Az előbbi kikötést, miszerint csak a Paulhoz tartozó kertre kell teljesülnie, hogy a zöldségek száma 3, implikációra cseréltük.

    \begin{equation}
    tulaj_t=4 \rightarrow \sum_{z\in Zoldsegek} J_{z,t} =3 \qquad \forall t\in Tulaj
    \end{equation}

    Ez a leírás javította a megoldó hatékonyságát, ahogy az a 3. fejezetben bemutatott futási eredményekből is látszik, így a további modellekben már csak ezt a fajta megfogalmazást 
    használtuk.


\subsection{Tulaj hozzárendelési mátrix}

    A harmadik verzióban már a meglévő termény mátrix mellé felvettünk még egyet a tulaj-kert kapcsolatokhoz.
    Az új mátrix szintén egyesekkel és nullákkal lett feltöltve.
	
	\begin{table}
		\centering
		\caption{}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline 
			& Luke & Sam & Hank & Paul & Zick \\ 
			\hline 
			Kert1 & 0 & 0 & 1 & 0 & 0 \\ 
			\hline 
			Kert2 & 0 & 1 & 0 & 0 & 0 \\ 
			\hline 
			Kert3 & 0 & 0 & 0 & 1 & 0 \\ 
			\hline 
			Kert4 & 0 & 0 & 0 & 0 & 1 \\ 
			\hline 
			Kert5 & 1 & 0 & 0 & 0 & 0 \\ 
			\hline 
		\end{tabular}
	\end{table}
     

    A kikötések felépítésében itt nincs változás, tehát nem sok különbség van a két változat között.

\subsection{Termény halmazok}

    A következő ötletünk az volt, hogy a kétdimenziós tömb helyett halmazokkal reprezentáljuk a megoldást.

    \Abra{set_declaration}{}{width=14cm}

    A tulajokat csak egy egyszerű tömbben tároltuk itt el, mint az első két változatban.

    Két fontos új kifejezés is megjelent a kikötésekben ennél a munkánál.
    Az első a „card” nevű függvény, ami megadja a részhalmaz elemszámát.

    \begin{equation}
    \left\| Termeszt_k \right\| =3 \qquad \forall k \in Kertek
    \end{equation}

    Ehhez a „card”-hoz használtunk még helyenként az „intersect” függvényt is, ami két halmaz metszetét állítja elő.

    \begin{equation}
    I_t=4 \rightarrow \left\| Zoldsegek \cap termeszt_t =3 \right\| \quad \forall t \in Tulaj
    \end{equation}

    A másik újdonság az "array union", ami a tömbben tárolt halmazok unióját képezi.
    
    \begin{equation}
     \left\| \textdollar termeszt= \textdollar termenyek \right\| 
    \end{equation}

\subsection{Integer mátrix}

    A Kertek utolsó verziójában ismét visszatértünk a mátrixos megoldáshoz, ám itt már nem bináris értékekkel töltöttük fel, hanem konkrétan a terményekkel.
    Az első dimenzió maradt a kertek halmaza, de a második dimenzió már nem az összes terményen megy végig, hanem a 4 termesztett növényen, és nem bináris értékekkel történik a hozzárendelés, hanem 4 növénytípus „enum”-ként való megadásával.
    Egy másik fontos változtatás volt, hogy itt mivel nem tudtunk sorösszegeket számolni, így a „count”-ot kellett használnunk.


    \Abra{count0}{}{width=14cm}

    Egy plusz kikötést kellett még írnunk ehhez a változathoz, az egy megoldás megtartása érdekében.
    Le kellett fixálni a termények sorrendjét, hogy ne adja meg ugyanazt a megoldást különböző sorrendekkel a megoldó, így megkötöttük, hogy a 4 növény sorszám alapján növekvő sorrendben szerepeljen.
    Ennek a módszernek pontos szemléltetése a 15.ábrán látható.

    \begin{equation}
    termeszt_{k,n} < tulaj_{k,n+1} \qquad \forall k \in Kertek, n \in 1,\dots,Noveny
	\end{equation}

\subsection{Kimenet formázása}

    A kimeneteket egységesen minden verziónál formáztuk a jobb olvashatóság érdekében.

    %kód
    \Abra{output1}{}{width=14cm}

    Ötből három változatban az adatokat külső fájlban vannak tárolva, így például, ha csak a növények neveit szeretnénk módosítani, nem kell az egész programot átírni hanem csak az adatfájlt.
    Ez a módszer is egy jó megoldás, ha munkát szeretnénk spórolni később.

\section{Zebra feladatok}

    A bevezetőben bemutatott Einstein-féle úgynevezett Zebra Puzzle-típusú fejtörők\cite{zebra} modellezése és megoldása tette ki kutatási tevékenységünk nagy részét.
    A cél az volt, a minél több féle adatszerkezettel és esetleg egy adatszerkezethez is minél több féle módon leírható korlátozások készítése.
    A könnyebb kezelhetőség illetve az átláthatóság érdekében a korlátozások felépítésük alapján kategorizálásra kerültek, így az ugyan más tartalmú, de hasonló logikai felépítésű kifejezések megírásakor jelentős mennyiségű időt lehetett megtakarítani.
    A következőkben részletesen bemutatásra kerülnek az ezen példák megoldására készített modellek.
    A két példa, amelyekkel részletesen foglalkoztunk a „Movies Night” névre hallgató „könnyű” nehézségi szintű és a „Fundraising Dinner” nevű „nagyon nehéz” nehézségű voltak.
    Továbbá mindegyikhez két különböző adatszerkezeti megvalósítás, illetve ezeken belül további kétféle korlátozás-leírási mód készült.

\subsection{Movies példa bináris mátrixszal}

    Az első 4x5-ös nagyságú példa: adott 4 barát, akik egy este moziba mentek, ahol egymás mellé ültek le.
    Mindegyikük azon felül, hogy hányadik széken ül, 5 tulajdonsággal jellemezhető:
    \begin{enumerate}
    	\item Milyen színű inget visel: fekete, kék, zöld, piros
    	\item Keresztnév: Daniel, Joshua, Nicholas, Ryan
    	\item Milyen típusú film a kedvence: akció, vígjáték, horror, thriller
    	\item Nassolnivaló: chips, süti, cracker, popcorn
    	\item Életkor: 11, 12, 13 és 14 éves
    \end{enumerate}
    Ahhoz, hogy megtudjuk, melyik széken ki ült és milyen tulajdonságokkal rendelkezik, rendelkezésre áll 13 állítás, amelyeket a modellezés során korlátozásokként(constraint) kezeltünk.
    Az első verziójú modell esetében a 4 fiú adatainak tárolására tulajdonságtípusonként egy-egy bináris értékeket(0, 1) tartalmazó 2 dimenziós mátrix került deklarálásra.

    \definecolor{mygreen}{rgb}{0, 0.5, 0}
    \lstset{ 
    	backgroundcolor=\color{white},   
    	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    	breaklines=true,                 % sets automatic line breaking
    	captionpos=b,                    % sets the caption-position to bottom
    	extendedchars=true,              
    	frame=single,	                   % adds a frame around the code
    	keepspaces=true,                 
    	morekeywords={constraint, enum, set, where, if, output, array, of, var, in},
    	keywordstyle=\color{mygreen},       % keyword style
    	keywordstyle={[2]\color{blue}},
    	keywords=[2]{forall, count, show, format, alldifferent, fix},
    	numbers=left,                    
    	numbersep=5pt,                   % how far the line-numbers are from the code
    	rulecolor=\color{black},         
    	showspaces=false,                
    	showstringspaces=false,          % underline spaces within strings only
    	showtabs=false,                  % show tabs within strings adding particular underscores
    	stepnumber=1,                    
    	tabsize=3,	                   % sets default tabsize to 2 spaces
    	title=Tömbök deklarációja
    }
    
    \begin{lstlisting}
    int: db = 4;
    set of int: PEOPLE = 1..db;
    
    enum NAMES = {Daniel, Joshua, Nicholas, Ryan};
    enum MOVIES = {action, comedy, horror, thriller};
    [...]
    
    array[COLORS, PEOPLE] of var {0, 1}: shirt;
    array[NAMES, PEOPLE] of var {0, 1}: name;
    [...]\end{lstlisting}

    A mátrixok sorai az egyes tulajdonságok konkrét értékeit az oszlopai pedig sorrendben a fiúk moziban elfoglalt helyét jelölik.
    A MiniZinc nyelv sajátosságait kihasználva, a sorokat egy-egy felsorol(enum) típusú tömb indexeli.
    Ennek a megoldás kiíratásánál illetve a korlátozások megfogalmazásánál lesz különös szerepe.
    Az oszlopok indexelésére pedig szintén a leíró nyelv sajátossága miatt egy {1..4} értékkészletű segédhalmazt(PEOPLE) használtunk, ahogy az a \ref{fig_binary_mtx}. ábrán is látható.
    Vegyünk egy példát: amennyiben a movie mátrix 3. sorának és 1. oszlopának metszetében az 1-es érték szerepel(\texttt{movie[horror, 1]=1}) azt jelenti, hogy az első helyen ülő fiúnak a horrorfilm a kedvence.
    A \texttt{db} változóra a teljeskörű paraméterezhetőség miatt van szükség, értéke jelen esetben a fiúk(és egyben kategóriánként a különböző tulajdonságok) számával egyenlő. A későbbiekben fogjuk sűrűn használni.
    Belátható, hogy mivel egy tulajdonság kategóriából minden fiúhoz(egész pontosan ülőhelyhez, mivel még nem tudjuk, ki hol ül) pontosan egy értéket rendelhetünk hozzá, ezért az összes bináris mátrix sor- és oszlopösszegeinek egyenlőnek kell lenniük 1-gyel.
    Ezt hivatottak biztosítani az alábbi korlátok(\ref{eq:1}).

    \begin{equation} \label{eq:1}
    \begin{aligned}
    \sum_{n\in N} name_{n,p} =1 \qquad \forall p \in People \\
    \sum_{p\in P} name_{n,p} =1 \qquad \forall n \in Names
    \end{aligned}
    \end{equation}

    A forall biztosítja, hogy minden sorra(ill. oszlopra) teljesüljön az, hogy a sum függvény visszatérési értéke(amely az oszlopot ill. sort összegzi) 1.
    Ezek után következik a 13 korlátozás megfogalmazása.
    Ezen példa esetében 6 különböző típusú korlátozás volt azonosítható, amelyek esetében a kifejezések szerkezete változatlan csak az adatok(egész pontosan az indexelés) változik.
    Az I. típusnál konkrétan megmondják, hogy mely pozícióban milyen tulajdonságú ember ül(\ref{eq:2}).

    \begin{equation} \label{eq:2}
     age_ {fourteen,3}=1 
     \end{equation}

    A II. típus hasonló az elsőhöz, de itt a széksor valamelyik széléről nyilatkozunk(\ref{eq:3}).
    Itt kihasználjuk, hogy bináris mátrixszal dolgozunk, ezért két elem összege 1 kell, hogy legyen, miszerint vagy az egyik szélen vagy a másikon ülhet Joshua.

    \begin{equation}  \label{eq:3}
    name_{Joshua,1} + age_{Joshua,db} =1
    \end{equation}

    A III. típusú korlátozás két tulajdonságot kapcsol össze egymással(\ref{eq:4}).

    \begin{equation} \label{eq:4}
    name_{Joshua,szek} = movie_{horror,szek} \qquad \forall szek \in People
    \end{equation}

    A IV. típus valamely tulajdonságú személy mellett közvetlenül balra(illetve jobbra) ülő emberről állít valamit(\ref{eq:5}).
    Itt viszont ki kell kötnünk, hogy az első helyen(tehát a bal szélen) nem ülhet a thriller kedvelő, mivel az ő bal oldalán már nem ülhet senki.
    A korlátozás megfogalmazásánál ez esetben az implikációs operátort(->) használtuk, amely kimondja, hogy ha megtaláltuk a thrillerkedvelőt, akkor fekete inges ül mellette(igaz állításból csak igaz következhet), egyéb esetben nem történik semmi.(hamis állításból bármi következik).
    Ennek kiváltására használtunk egy továbbfejlesztett korlátozás-leírási mód esetén tisztán relációs operátorokat(\ref{eq:6}).

    \begin{equation} \label{eq:5}
    \begin{aligned}
    &movie_{thiller,1}=0 \\
    &movie_{thriller,szek}=1 \Rightarrow shirt_{black,szek}=1 \quad \forall szek \in 2..db
    \end{aligned}
    \end{equation}
    
    \begin{equation} \label{eq:6}
    \begin{aligned}
    &movie_{thiller,1}=0 \\
    &movie_{thriller,szek}= shirt_{black,szek} \quad \forall szek\in 2..db
    \end{aligned}
    \end{equation}

    Az V. típusnál adott ember valamely tulajdonságú ember mellett balra (ill. jobbra) tetszőleges pozícióban foglal helyet (\ref{eq:7}).
    A második verzióban szintén relációs operátort (kisebb-egyenlő) használtunk az implikáció kiváltására (\ref{eq:8}).

    \begin{equation} \label{eq:7}
    (age_{eleven,x}=1) \rightarrow (\sum_{ szek \in 1..x-1 } shirt_{black,szek}=1) \quad \forall x \in People
    \end{equation}
    \begin{equation} \label{eq:8}
    age_{eleven,x} <= \sum_{szek \in 1..x-1} shirt_{black,szek} \quad \forall x \in People
     \end{equation}

    A VI. típusnál egy ember valamely két másik között tetszőleges pozícióban foglal helyet(\ref{eq:9}).
    Ebben az esetben viszont a logikai operátor relációsra cseréléséhez két részre kellett bontanunk az állítást(\ref{eq:10}).

   \begin{equation} \label{eq:9}
    (age_{thirteen,x}=1 \wedge movie_{action,y}=1) \rightarrow (\sum_{szek\in x+1..y-1} shirt_{red,szek}=1) \quad\forall x,y \in People
   \end{equation} 
    
   \begin{equation} \label{eq:10}
   \begin{aligned}
   age_{thirteen,x} <= \sum_{szek\in x+1..db} shirt_{red,szek} \quad \forall x \in People \\
   movie_{action,x} <= \sum_{szek\in 1..x-1} shirt_{red,szek} \quad \forall x \in People
   \end{aligned}
   \end{equation}

    A kimenet képzése a MiniZinc nyelvnek megfelelő szintaktikával valósult meg.
    
	\begin{lstlisting}
	output [format(width, show(n)) ++ "\t" | t in PEOPLE, n in NAMES where 		  fix(name[n,t])=1]++["\n"];\end{lstlisting}

    A format függvény pusztán esztétikai formázást, a show karakterlánccá konvertálást, a fix függvény pedig a változók értékének kiíratás előtti „stabilizálását” végzi.
    A where záradékban pedig azt vizsgáljuk, hogy a bináris mátrixban hol található 1-es érték, mert csak azokat az értékeket íratjuk ki.

\subsection{Fundraising Dinner példa változó tömbökkel}

    Az eddigiekben részletezett bináris mátrix mellett egy másik, ettől merőben eltérő adatszerkezettel rendelkező implementációt is készítettünk.
    Ezt a második, 5x6-os méretű feladatunkon, a „Fundraising Dinner” címűn keresztül fogjuk bemutatni.
    Néhány szó magáról a feladatról: a leírás szerint 5 jómódú hölgy egy jótékonysági vacsorán vesz részt.
    Egy egyenes asztalnál, egymás mellett foglalnak helyet és mindegyikük 6 féle tulajdonsággal jellemezhető:
    \begin{enumerate}
    	\item Keresztnév
    	\item Viselt ruha színe
    	\item Nyakláncukon található drágakő típusa
    	\item Életkoruk
    	\item Fogyasztott koktéljuk
    	\item Adakozott pénzmennyiség dollárban
    \end{enumerate}
    Ennél az adatstruktúránál tulajdonságkategóriánként egy-egy felsorol(enum) típusú egydimenziós tömböt készítettünk, amelyet a már említett segédhalmazzal indexeltünk.

    \definecolor{mygreen}{rgb}{0, 0.5, 0}
    \lstset{ 
    	backgroundcolor=\color{white},   
    	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    	breaklines=true,                 % sets automatic line breaking
    	captionpos=b,                    % sets the caption-position to bottom
    	extendedchars=true,              
    	frame=single,	                   % adds a frame around the code
    	keepspaces=true,                 
    	morekeywords={constraint, enum, set, where, if, output, array, of, var},
    	keywordstyle=\color{mygreen},       % keyword style
    	keywordstyle={[2]\color{blue}},
    	keywords=[2]{forall, count, show, format, alldifferent},
    	numbers=left,                    
    	numbersep=5pt,                   % how far the line-numbers are from the code
    	rulecolor=\color{black},         
    	showspaces=false,                
    	showstringspaces=false,          % underline spaces within strings only
    	showtabs=false,                  % show tabs within strings adding particular underscores
    	stepnumber=1,                    
    	tabsize=3,	                   % sets default tabsize to 2 spaces
    	title=Tömbök deklarációja
    }
    
    \begin{lstlisting}
    array[PEOPLE] of var COLORS: dress;
    array[PEOPLE] of var NAMES: name;\end{lstlisting}

    Itt a tárolt értékek már a konkrét tulajdonságok neveit vehetik fel, sorrendjük pedig meghatározza, hogy melyik széken ülő emberre mi jellemző.
    Egy tömbön belül az értékek egyediségét az alldifferent globális constraint biztosítja.
   
    \begin{lstlisting}
    constraint alldifferent(dress);
    constraint alldifferent(name);\end{lstlisting}

    A korábban már részletezett korlátozástípusok jelen adatstruktúra esetében a következőképpen lettek modellezve.
    Az I. illetve II. típusú kikötés ebben a példában nem fordult ugyan elő, de modellezése hasonló módon történik, mint a „Movies” példa esetén.
    A III.(\ref{eq:11}) és IV. típus(\ref{eq:12}) esetén egyféle leírási mód választható csak.

    \begin{equation} \label{eq:11}
    (name_p=Jane) \leftrightarrow (donation_p=twentythousand) \quad \forall p \in People
    \end{equation}

    A IV. típusú korlátozás leírásánál is az ekvivalencia operátor(<->) használata figyelhető meg.
    Azokat az eseteket, amelyeknél az említett személyek valamely szélén ülnek a széksornak, itt külön kell kezelni, mivel ekkor egyértelmű egymáshoz viszonyított helyzetük.
    Másrészt pedig így elkerülhető a tömbök bejárása során a 
    kiindexelés.

	\begin{equation} \label{eq:12}
	\begin{aligned}
	&cocktail_p=cosmopolitan \leftrightarrow age_{p+1}=sixty \\
	&\quad\quad\forall p \in 1..db-1 \wedge cocktail_{db} \neq cosmopolitan \wedge age_1 \neq sixty
	\end{aligned} 
	\end{equation}

    Az V. típus az implikáció operátorral pedig a \ref{eq:13}. ábrán látható.
    B változat esetében pedig az indexekkel való bejárásnál fogalmazható meg egy apróbb szabály(\ref{eq:14}).
	
	\begin{equation} \label{eq:13}
		\begin{aligned}
		&cocktail[x]=margarita \rightarrow count([dress[p] \quad \forall p \in 1..x-1], blue)=1 \quad \forall x \in PEOPLE \quad \wedge \\
		&dress[x]=blue \rightarrow count([cocktail[p] \quad \forall p \in x+1..db], margarita)=1 \quad \forall x \in PEOPLE \quad \wedge \\
		\end{aligned}
	\end{equation}
	
   \begin{equation} \label{eq:14}
    \neg(cocktail_a =margarita \wedge dress_b=blue) \quad \forall a,b \in People \wedge a<b
     \end{equation}

    A VI. korlátozástípusnál szintén kétféle modell készült, az A változatnál logikai 
    operátorral és a később részletesen taglalt visszafelé következtetés módszerével és a count függvény segítségével(\ref{eq:15}).
    B verziónál viszont újra az indexekkel való bejárásnál található egy apróbb kikötés(\ref{eq:16}).

    \begin{equation} \label{eq:15}
    \begin{aligned}  
    	&donation[x]=fourtythousand \rightarrow count([dress[p] \quad \forall p \in 1..x-1], red)=1 \quad \forall x \in PEOPLE \wedge \\
    	&dress[x]=red \rightarrow count([donation[p] \quad \forall p \in x+1..db], fourtythousand)=1 \quad \forall x \in PEOPLE \wedge \\
    	&donation[x]=twentythousand \rightarrow count([dress[p] \quad \forall p \in x+1..db], red)=1 \quad \forall x \in PEOPLE \wedge \\
    	&dress[x]=red \rightarrow count([donation[p] \quad \forall p \in 1..x-1], twentythousand)=1 \quad \forall x \in PEOPLE \wedge \\
    \end{aligned}
    \end{equation}
    
    \begin{equation} \label{eq:16}
    \begin{aligned}
    	&\neg(donation[a]=fourtythousand \wedge dress[b]=red) \quad \forall a,b \in PEOPLE \wedge a<b \qquad \wedge \\
    	&\neg(dress[a]=red \wedge donation[b]=twentythousand) \quad \forall a,b \in PEOPLE \wedge a<b \qquad \wedge \\
    \end{aligned}
    \end{equation}

    Ezen felül ennél a feladatnál azonosítható volt egy újfajta korlátozás, amely egy objektum valamely oldaláról nyilatkozik, viszont nem rögzíti, hogy melyikről.
    Ezeknél az úgy nevezett visszafelé következtetés is felhasználásra került.
    Az alábbi példát megvizsgálva észrevehető, hogy abból, hogy Lidia a Cosmopolitant ivó mellett ül, viszont következik az is hogy a Cosmopolitan fogyasztó mellett – üljön ő bárhol is - valamely oldalon kell helyet foglalnia Lidia-nak.
    Ezt az \texttt{xor}(kizáró vagy) operátor biztosítja.
    A széksor széleit a IV. típusnál részletezett okok miatt ismét külön kellett kezelni.

    \begin{equation}
    \begin{aligned}
     &(name_p=Lidia) \rightarrow (cocktail_{p-1}=cosmopolitan \oplus cocktail_{p+1}=cosmopolitan) \\ 
     &\quad \quad \forall  p \in 2..db-1 \quad \wedge \\
   	 &(cocktail_p=cosmopolitan) \rightarrow (name_{p-1}=Lidia \oplus name_{p+1}=Lidia) \quad  \wedge \\
     &(name_1=Lidia \rightarrow cocktail_2=cosmopolitan) \quad \wedge \\
     &(name_{db}=Lidia \rightarrow cocktail_{db-1}=cosmopolitan) \quad \wedge \\
     &(cocktail_1= cosmopolitan \rightarrow name_2=Lidia) \quad \wedge \\
     &(cocktail_{db}=cosmopolitan \rightarrow name_{db-1}=Lidia) \quad \quad \forall p \in 2..db-1
     \end{aligned}
    \end{equation} 
    
    Az eredmény kiíratásánál itt kihasználható az, hogy a tömb elemeit nem kell vizsgálni, hanem sorrendben, vizsgálat nélkül kiírathatóak.
	
	\begin{lstlisting}
	output [format(width,show(dress[p])) ++ "\t" | p in PEOPLE]++["\n"];\end{lstlisting}

\section{Teszteredmények}

    A kiválasztott példák különféle módokon történő modellezésének végeztével, az így rendelkezésre álló modellek átfogó teszteknek lettek alávetve.
    Érdeklődésünk középpontjában az állt, hogy a különböző nehézségű példák, illetve az elérő módon modellezett korlátozások miként befolyásolják a megoldók hatékonyságát.
    A korábbi fejezetben már vázolt „Gardens” nevű példa elkészülte után, a tesztelés kezdeteként a MiniZinc IDE és a Gecode megoldó két verzióját is összevetettük egymással.

    \Abra{futasido1}{}{width=14cm}

    A \ref{fig_futasido1}. ábra tartalmazza a futási eredményeket milliszekundumban(ms) mérve.
    Megoldóként ez esetben a Gecode-ot használtuk.
    Az átlag mindegyik esetben 6 futtatás számtani közepe.
    Az adatokból több következetés is levonható.
    Egyrészről, a 2.1.6-os verzió minden esetben valamivel lassabban oldotta meg a példákat, elmondható, hogy készítői láthatóan javítottak termékükön és optimalizálták a hatékonyságát.
    A második szembetűnő jelenség, miszerint az készített alapmodell/alapverzió, még meglehetősen nyersnek bizonyult megoldhatóság szempontjából is.
    A futási eredmények jó okot szolgáltatnak a forall függvény where záradékában döntési alapként felhasznált, értékkel még nem feltétlenül rendelkező változók használatának kerülésére.

    Harmadrészt pedig jól látható, hogy az olyan speciális, nem „Einstein-típusú” logikai feladvány esetében, mint amilyen a „Gardens” is, nem szerencsés a tömböket használó adatreprezentáció választása.
    Részben a lassú megoldáskeresés, részben pedig a bonyolult megvalósítás miatt sem.
    A bináris mátrixok illetve halmazok használata között jelentős futásidőbeli eltérés nem volt.
    Főként annak tükrében, hogy az újabb verziónál teljesen azonos volt az átlagos futásidő mindkét modelltípus esetében.
    Ám a régebbi verzió esetében is csak nagyon kis mértékben bizonyultak hatékonyabbnak a bináris mátrixos adatstruktúrák.
    A következőkben a Zebra vagy Einstein-típusú logikai fejtörők hatékonyságának 
    összehasonlítása következik.
    Jelen esetben 2 példa állt rendelkezésünkre: A „Movies 
    Night” mint 4x5-ös nagyságú könnyebb és a „Fundraising Dinner”, mint 5x6-os nehezebb 
    feladat.
    Megoldóként továbbra is a Gecode-ot használtuk, és az átlagszámítási módszer 
    is azonos volt az előzőekben ismertetetthez.

    \Abra{futasido2}{}{width=14cm}

    Amint az a \ref{fig_futasido2}. ábrán látható a „Fundraising Dinner” feladat esetében hosszabb futásidőket tapasztalhatóak, mint a „Movies Night” esetében, amely a példa összetettebb mivoltát tekintve nem meglepő.
    Az viszont már jóval szembetűnőbb, hogy az eltérés nagyon kicsi, ami jelzi, hogy a megoldó egy nagyobb és nehezebb, több hozzárendeléssel dolgozó feladat esetében is képes a futásidőket abszolút alacsony szinten tartani.
    Ez komoly érv amellett mikor eszközt választunk a hasonló típusú feladatok megoldásához.
    Más modellezési technikákhoz képest a korlátprogramozás esetében nem a feladat összetettségének mértékében nőnek a futásidők, hanem annál jelentősen lassabban, és ez a futásidő növekedés is csak a hozzárendelések számának jelentős növelésekor mutatkozik meg igazán.

    Emellett, a jóval gyakoribb Einstein alkotta Zebra Puzzle-ök modellezésekor sokkal célszerűbb egy tömböket használó adatstruktúrát megvalósítani.
    Mind a modellezés során a könnyebb kezelhetőség, mind pedig a jóval rövidebb futásidők szempontjából sokkal optimálisabb, ha ezt az adatreprezentációt részesítjük előnyben.
    Összegzésként, a végső konzekvenciákat levonva: a korlátprogramozás a kifejezetten rövid megoldási és futásidőket figyelembe véve, egy borzasztóan hatékony eszköz a vizsgált logikai fejtörők, mint speciális hozzárendelési feladatok modellezéséhez.
    A gyakori és sokak által ismert Einstein-féle feladatok esetében a felsorol típussal indexelt tömbök használatát célszerű választani.
    Viszont az olyan nem hétköznapi példáknál – amilyen ez esetben a „Gardens” is volt – ahol nem beszélhetünk a klasszikus egy-az-egyhez hozzárendelésről már más a helyzet.
    Ez esetben javasolt valamilyen halmazokkal dolgozó adatszerkezet, esetleg bináris mátrixok deklarációja az maximális hatékonyság elérése érdekében.

\chapter{Redundáns megkötések megkeresése}

    A példák korlátozásainak modellezése során felmerült annak lehetősége, hogy redundáns kifejezések fordulhatnak elő a feladatokban, azaz vannak olyan megkötések vagy megkötés-halmazok, amelyek elhagyása esetén továbbra is egyetlen, az eredeti feladatkiírásnak megfelelő megoldást talál a megoldó.
    Célunk ezek megkeresése, továbbá annak meghatározása volt, hogy elhagyásuk miképpen befolyásolja, vagy befolyásolja-e egyáltalán a különböző megoldók futási illetve megoldási idejét.
    Mivel a megoldók gyorsasága már a korábbiakban bebizonyosodott, ezért nagy esély mutatkozott arra, hogy  egy vagy több korlátozás eltávolítása esetén is rövid idő alatt meg lehet határozni, hogy továbbra is egyértelmű-e az eredmény.
    A feladatok jellegéből adódóan egyértelműnek az az eset volt tekinthető, amikor a program lefutása után csak egy megoldást talál, amely az eredeti – minden kikötést tartalmazó – feladatkiírásnak is megfelel.
    Módszerünk a következő volt: minden kikötést egy elágazásban helyeztünk el(\ref{fig_selection}. ábra).

    \definecolor{mygreen}{rgb}{0, 0.5, 0}
    \lstset{ 
    	backgroundcolor=\color{white},   
    	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    	breaklines=true,                 % sets automatic line breaking
    	captionpos=b,                    % sets the caption-position to bottom
    	extendedchars=true,              
    	frame=single,	                   % adds a frame around the code
    	keepspaces=true,                 
    	morekeywords={constraint, then, else, in, endif, xor, where, if},
    	keywordstyle=\color{mygreen},       % keyword style
    	keywordstyle={[2]\color{blue}},
    	keywords=[2]{forall, count},
    	numbers=left,                    
    	numbersep=5pt,                   % how far the line-numbers are from the code
    	rulecolor=\color{black},         
    	showspaces=false,                
    	showstringspaces=false,          % underline spaces within strings only
    	showtabs=false,                  % show tabs within strings adding particular underscores
    	stepnumber=1,                    
    	stringstyle=\color{red},     % string literal style
    	tabsize=3,	                   % sets default tabsize to 2 spaces
    	title=Elágazásba ágyazott kikötés
    }

    \begin{lstlisting}
    	constraint if kivesszuk[4]=1 then true else
    		forall(p in PEOPLE)(necklace[p]=sapphire <-> age[p]=fiftyfive)
    	endif;\end{lstlisting}
    

    A „kivesszuk” egy, a korlátozások számával egyező elemszámú bináris értékeket tartalmazó tömb.
    Amennyiben a tömb adott indexű eleme 1 értéket tartalmaz, akkor a korlátozás a konkrét kifejezés értéke helyett egyszerűen igaz értéket vesz fel, így a kifejezést figyelmen kívül lesz hagyva.
    Amennyiben viszont az adott sorszámú elem 0 értékű, akkor a különben ágban elhelyezett, a feladatleírásnak megfelelően modellezett kifejezés lesz korlátozásként kezelve.
    Ezen elvet követve mindegyik korlátozás egy a fenti ábrához hasonló vezérlési szerkezetbe került beágyazásra.
    A "kivesszuk” tömböt pedig a könnyebb szerkeszthetőség érdekében nem a modellen belül lett definiálva, hanem értéke külön fájl(ok)ból lett beolvasva.
    Mivel egyes példák nagy mennyiségű kikötést tartalmaznak és ebből következően rengeteg féle kombinációban lehetne ezeket elhagyni, így igyekeztük ezeket a teszteket valamilyen szinten automatizálni.
    Az adatfájlok (a "kivesszuk” tömb definícióját tartalmazó) egy C Sharp programmal voltak generálva oly módon, hogy első körben mindegyikben a tömbnek pontosan egy eleme lesz 1 értékű, így értelemszerűen a korlátozások darabszámával egyező adatfájl keletkezett.
    Ezeket a modellel együtt parancssorból futtattuk és feljegyeztük azokat a sorszámokat, amelyek esetén egyértelmű eredmény született.
    Második körben az imént említett C Sharp program legenerálta ezen összegyűjtött sorszámok összes létező, 2 tagból álló kombinációját, majd újabb parancssoros futtatás következett.
    Megint feljegyeztük az eredményeket és ezt ismételtük mindaddig, amíg a sorszámok értékkészlete le nem szűkült teljesen.
    A kapott eredmények meglepőek voltak.
    
    Még egy olyan kicsi és gyenge nehézségű, kevés kikötésből álló példánál is, mint amilyen a „Movies Night”, relatíve jelentős mennyiségű kikötés elhagyása esetén is teljesült, hogy az egyetlen kapott megoldás megegyezett a kiindulási feladat megoldásával.
    Ez esetben az összes 13-ból önmagában 3 korlátozás is redundánsnak bizonyult.
    Ezekből pedig 3 olyan különböző 2 tagból álló kombináció volt alkotható, amelyek egy időben is elhagyhatóak.
    Ezen számok a nagyobb példák esetében még tovább nőttek.
    A feldolgozott példák esetében a redundáns kikötések eloszlásait a \ref{elhagyhato}. táblázat tartalmazza.

    
    \begin{table}[h]
    	\centering
    	\caption{}
    	\label{elhagyhato}   
    	\begin{tabular}{|c|c|c|c|}
    		\hline 
    		& Movies Night & Fundraising dinner & Gardens \\ 
    		\hline 
    		1 tagú kombinációk & 3 & 7 & 5 \\ 
    		\hline 
    		2 tagú kombinációk & 3 & 15 & 5 \\ 
    		\hline 
    		3 tagú kombinációk & 0 & 13 & 2 \\ 
    		\hline 
    		4 tagú kombinációk & 0 & 4 & 0 \\ 
    		\hline 
    	\end{tabular} 
    \end{table}
    

    Az adatokból kitűnik, hogy azon korlátozások közül, amelyek önmagukban elhagyhatóak, nem választható ki tetszőleges kombinációban 2 vagy több.
    Azaz már meg kell válogatni, hogy pontosan melyek együttes elhagyása ad egyértelmű eredményt.
    Tehát például ha két kifejezés külön-külön elhagyható, az korántsem jeleni azt, hogy ezek egyszerre is elhagyhatók.
    Vegyünk egy konkrét példát: a „Fundraising dinner” esetében az elhagyható korlátozásokból(7) alkotható összes 2 tagú kombináció száma 21, de ezek közül csak 15 ilyen pár felelt meg a kitételeknek.
    Jellemzően minél több kifejezést szeretnénk egy időben feleslegessé minősíteni, annál inkább szűkül a választási spektrum, annál kevesebb kombináció jöhet számításba.
    Egy idő után elértük azt a küszöbértéket, amelynél több kifejezés nem hagyható el egyszerre.
    Ez jellemzően az összes kikötés számának 15-23\%-a volt.
    
    A fentiek továbbá azt is jelentik, hogy a feladat megalkotói jelentős redundanciával dolgoztak a kikötések meghatározásánál.
    Ám ezt megállapítani a klasszikus módszerrel, miszerint egyszerűen kevesebb korlátozással kiírt példát akarunk megoldani papíron, sokszor egy átlagos képességű embernek nem lehetséges vagy túlságosan hosszú ideig tart.
    Esetünkben viszont egzakt matematikai-logikai modellekkel leírt korlátozásokat a számítógép oldotta meg, amely értelemszerűen az emberénél jóval nagyobb számítási kapacitással rendelkezik.
    Így a nem feltétlenül szükséges kifejezések felderítése viszonylag rövid idő alatt, egyszerű eszközökkel kivitelezhető volt.
    
    Futásidők tekintetében a módosítatlan, teljes feladathoz képest a kihagyásoknál jelentős változás sem a parancssoros sem a grafikus felületről történő futtatás során nem történt, bár egyes esetekben kis mértékben a futásidők megnőttek.
    A megoldók hatékonysága ismét bebizonyosodott, mivel kevesebb korlát, így a megoldáskeresés során kevesebb támpont esetén is komoly gyorsasággal adtak eredményt.
    
    Mindez felhasználható feladványok készítésekor a minél nehezebb feladatok eléréséhez, melyekben minden információt fel kell használni a megoldás során. A következő fejezet pontosan ezt tárgyalja, miszerint a különböző modellek, illetve a példa méretének növekedése milyen hatással van a futásteljesítményre.
    
    \chapter{Saját készítésű "óriás" feladvány}
    
    Az előző fejezetben tárgyalt redundáns korlátozások eltávolításakor merült fel a gondolat, hogy a felesleges kifejezések keresésére készített automatizmust valamilyen formában felhasználható lenne egy saját, a különböző forrásokból elérhető logikai feladványoknál nagyságrendekkel nagyobb példa létrehozására.
    
    A szakirodalomban, illetve internetes forrásokból elérhető, főként Zebra típusú logikai feladványok - köztük még a legnehezebbek is - maximum 6 tulajdonság kategóriával illetve maximum 5 különböző objektummal(általában emberrel) dolgoznak. Egyébként ezek pont a Fundraising Dinner feladvány méretei, mivel többek között ez rendelkezett maximális nagysággal. Ez részben érthető mivel ezeket emberek tervezték embereknek, akik szórakozásból oldják meg őket, többnyire papíron, így túlságosan nagy példa részükre nem adható. Mivel nekünk azonban rendelkezésre állt több különböző modell, így ezek még hitelesebb és szembetűnőbb összehasonlítására egy óriás példa létrehozása és tesztelése kézenfekvőnek tűnt.
    
    Ehhez egy 15x15-ös logikai feladványt alkottunk azaz 15 tulajdonságkategóriában egyenként 15 tulajdonság(tehát példaszinten 15 objektum/ember) volt. Így összesen 225 különböző, kitalált tulajdonsággal dolgoztunk. Ez az elérhető legnagyobb példa 30 tulajdonságának 7,5-szerese így elmondható, hogy egy szélsőségesen nagy példát sikerült létrehozni. Ehhez összesen 238 darab korlátozás került megfogalmazásra úgy, hogy a 2.2. fejezetben bemutatott 6 típusú korlátozás mindegyikéhez körülbelül egyenlő számú tartozzon. Ezek típusonként egy-egy .csv típusú fájlba speciális formátumban lettek rögzítve. Majd egy általunk készített C Sharp nyelven írt kódgenerátor ezeket a fájlokat végigjárva MiniZinc nyelven írt korlátozásokká alakította, majd egy .mzn kiterjesztésű fájlba írta őket.
    
    \definecolor{myblue}{rgb}{0.165, 0.623, 0.792}
    \definecolor{myred}{rgb}{0.639, 0.082, 0.082} 
    \lstset{ 
    	language = csh,
    	backgroundcolor=\color{white},   
    	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    	breaklines=true,                 % sets automatic line breaking
    	captionpos=b,                    % sets the caption-position to bottom
    	commentstyle=\color{green},    % comment style
    	extendedchars=true,              
    	frame=single,	                   % adds a frame around the code
    	keepspaces=true,                 
    	morekeywords={while, for, string, new, using, int},
    	keywordstyle=\color{blue},       % keyword style
    	keywordstyle={[2]\color{myblue}},
    	keywords=[2]{List, StreamReader, String},
    	numbers=left,                    
    	numbersep=5pt,                   % how far the line-numbers are from the code
    	rulecolor=\color{black},         
    	showspaces=false,                
    	showstringspaces=false,          % underline spaces within strings only
    	showtabs=false,                  % show tabs within strings adding particular underscores
    	stepnumber=1,                    
    	stringstyle=\color{myred},     % string literal style
    	tabsize=3,	                   % sets default tabsize to 2 spaces
    	title=Kód generátor forráskódrészlete
    }
    
	\begin{lstlisting}
		string[] kategoriak = new string[15];
		List<string> output = new List<string>();
		string[] files = { "InOneOfTheEnds.csv", "Likes.csv", "SomewhereBetween.csv", "InPosition.csv", "SomewhereToTheLeft-Right.csv", "ExactlyToTheLeft-Right.csv" };
		string[] constraints = { "constraint {0}[1]={1} xor {0}[db]={1};",
		"constraint forall(szek in PEOPLE)({0}[szek]={1} -> {2}[szek]={3});",
		"constraint forall(x in PEOPLE)({4}[x]={5} -> count([{2}[szek] | szek in 1..x-1], {3})=1) /\\ forall(x in PEOPLE)({2}[x]={3} -> count([{0}[szek] | szek in x+1..db], {1})=1);",
		"constraint {0}[{3}]={1};",
		"constraint forall(x in PEOPLE)({2}[x]={3} -> count([{0}[szek] | szek in 1..x-1], {1})=1);",
		"constraint forall(szek in 2..db)({2}[szek]={3} -> {0}[szek-1]={1});",
		"constraint forall(x in PEOPLE)({2}[x]={3} -> count([{0}[szek] | szek in x+1..db], {1})=1);",
		"constraint forall(szek in 1..db-1)({2}[szek]={3} -> {0}[szek+1]={1});" };
		
		using (StreamReader sr = new StreamReader("Kategoriak.csv"))
		{
			int sorok = 0;
			while (!sr.EndOfStream)
			{
				kategoriak[sorok] = sr.ReadLine();
				sorok++;
			}
		}
		
		for (int i = 0; i < kategoriak.Length; i++)
		{
			output.Add(String.Format("array[PEOPLE] of var {0}: {1};", kategoriak[i].Split(";")[0] + "S", kategoriak[i].Split(";")[0]));
		}
		for (int i = 0; i < kategoriak.Length; i++)
		{
			output.Add(String.Format("constraint alldifferent({0});", kategoriak[i].Split(";")[0]));
		}
	\end{lstlisting}
    
    A fenti ábrán a kódgenerátor forráskódjának egy részlete látható, amely éppen a tömbös modellünk B verzióját készíti. A constraints tömbben található 8 db helyőrzőkkel(kapcsos zárójelek közötti számok) gazdagon tarkított string literál módosításával tetszőleges modell korlátozásai generálhatóak, sőt akár más programozási/modellezési nyelvekre is könnyedén átírható. Esetleg más, a logikai feladványok esetén alkalmazható módszer(pl genetikus algoritmusok célfüggvényei) nagy mennyiségű de azonos sémájú kódja esetén is alkalmazható univerzális eszköz. Ezen felül látható, hogy nem csak a korlátozások, hanem például a tömbök deklarációja, illetve a különbözőséget biztosító alldifferent sorokat is a generátor hozza létre(alsó két for ciklus), így még tovább csökkenthető a fölösleges munka egy-egy példa készítésekor.
    
    \Abra{futasido3}{}{width=14cm}
    
    Az összes általunk készített modell generálása után, futásidők tekintetében összehasonlítást végeztünk az óriás példán, illetve a szakirodalomban jelenleg elérhető legnehezebb példával a korábban megvizsgált Fundraising dinner-el. Az eredmények a \ref{fig_futasido3}. ábrán láthatóak. Az átlagszámítási módszer megegyezett a  3. fejezetben ismertetettel. A grafikonról leolvasható, hogy nem meglepő módon, az összes modell  esetében a futásidők megnövekedtek a könnyebb példához viszonyítva. Viszont az már érdekesebb, hogy a legkisebb mértékű növekedés a bináris mátrixokat és relációs operátorokat használó modell esetében jelent meg, itt csupán 9 ms amely szinte elhanyagolható. Ebből a szempontból pedig a legrosszabbul ugyanennek az adatreprezentációnak a logikai operátorokat tartalmazó változata teljesített(92 ms). Ennek ellenére a legjobb eredményt ezúttal is a felsorol típusú tömböket tartalmazó modell érte el, közülük is az A verzió, amely a 2.2.2. alfejezetben bemutatott formátumban, a B verzióval ellentétben teljesen mellőzi a where záradékot. Ebből levonhatjuk azt a következtetést, amelyet még a kisebb példa esetében jelentkező csupán 1 ms-os futásidő különbség esetén alaptalan lett volna kijelenteni. Miszerint ennél az óriás feladatnál már tapasztalt jelentős(52 ms) időbeli eltérés alapján, célszerű a korlátozások megfogalmazásakor a where záradék teljes körű mellőzése, még akkor is ha csupán indexeket és nem döntési változókat használunk benne(mint ahogyan az történt például a Gardens alapverziója esetén). Azonban jelen vizsgálati eredmények ismeretében már látható az, hogy mely modell szerzett ezüstérmet a képzeletbeli dobogón, ami a hatékonyságot illeti. Ugyanis míg nem állt rendelkezésre ezen óriás feladvány, addig a tömbös adatszerkezet B verziója tűnt kézenfekvő opciónak amennyiben ki szeretnénk választani a második leggyorsabban eredményt produkáló modellt. Viszont a korlátozások és változók számának ilyen drasztikus emelése után a tömbös modell B verziója szintén ugyanilyen drasztikus futásidő növekedést produkált. Ellenben a bináris mátrixos, relációs operátoros modell a hozzárendelendő tulajdonságok számának 750\%-os emelése esetén csupán 4,6\%-os futásidőbéli növekedést mutatott. Így habár ilyen nagy méretű példa esetén sem ez a leghatékonyabb megoldás, viszont a legjobban skálázható. Amint az látszik a Movies Night-Fundraising Dinner illetve Fundraising Dinner-Óriás Példa összehasonlításokból, ez a modell minél inkább növeljük a feladat nagyságát annál kisebb mértékben növeli a futásidőt, míg a tömbösnél ez éppen fordítva van.
    
    Összefoglalva: sem a relációs operátorok(különösen az implikáció és az ekvivalencia) sem pedig a where záradék használata nem ajánlott amennyiben Einstein-típusú logikai feladványokat szeretne valaki modellezni, mivel ezen elemek meglehetősen rontják a hatékonyságot. Helyettük inkább ajánlott felsorol típusú tömbök használata, illetve alternatívaként áll még a bináris mátrixok használata a relációs operátorokkal kombinálva.


\chapter{Összefoglalás}

    Munkánk során az „Einstein-féle” logikai feladványok szerkezetét és lehetséges megoldásukat vizsgáltuk.
    A feladatok általános modellezése végett megismerkedtünk a korlátprogramozás módszereivel.
    A feladatokat többféle módon modelleztük, és megvizsgáltuk az egyes modellek megoldási hatékonyságát.
    Ez után azt vizsgáltuk, hogy hogyan lehet kiszűrni a redundáns megkötéseket, amik elhagyásával még egyértelműen megoldható marad a feladat. Végül létrehoztunk egy saját készítésű, a szakirodalomban fellelhető feladványoknál nagyságrendekkel nagyobb példát. Ezen tesztelni tudtuk, hogy modelljeink mennyire bizonyulnak hatékonynak abban az esetben, ha a tulajdonságok és kikötések számát drasztikus mértékben emeljük meg.
			

\addcontentsline{toc}{chapter}{Irodalomjegyzék}
\bibliographystyle{plain}
\bibliography{gardens}				
				
\end{document}				